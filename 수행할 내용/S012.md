| 이름               |박진홍|
| ------------------ | --- |
| 선택한 퀘스트 번호 |1, 2, 3, 4|
| 선택한 이유        |설계 의도가 순차적으로 하나씩 수행하여 최종 결과를 만들어내는 것이라 의도에 맞게 수행해보기 위함|
| 수행 과정          |      |
| 발견한 개선점      |     |
| 수행 후 인사이트   |     |

#### 발견한 개선점
- 퀘스트의 예시에는 내가 어떤 성향, 장·단점, 어떤 개발자인지 그간의 대화를 바탕으로 얻도록 유도함
- 그러나 계정을 공유하거나 대화를 전부 추적할 수 없는 1회용 세션 AI를 위주로 쓰는 사람이라면 대화를 바탕으로 한 피드백 획득이 어려울 수 있음
- 따라서 챌린지 과정이나 **기존에 작성한 코드, 학습 정리, 설계를 전달하여 분석받아 개발자로서의 성향을 피드백 받는다**면 좋을 것이라 생각함
- 특히 학습 시키는 내용이 많을수록 더욱 자세하고 정밀한 피드백을 받을 가능성이 높아질 것으로 예상됨
- 이는 **몰랐던 자신만의 개발 철학을 발견할 수 있는 계기**가 될 수도 있을 듯함

#### 수행 과정
- 사용한 AI: NoteBookLM
  - AI 선택 이유: 원하는 소스를 안전하게 학습 시켜 근거에 기반한 피드백을 받기 가장 적절하기 때문
- 소스 제공
  - 기존 프로젝트 1개 분량 코드와 설계, 트러블 슈팅 등을 전달
  - 챌린지 미션 1–4, 베이직 미션 1–10에 해당하는 gist 링크 전달
- 질문 프롬프트
  - 기술 스택, 숙련도, 설계 및 아키텍처 사고, 문제 해결 방식, 학습 방식, 학습 성향, 커뮤니케이션 또는 협업에서의 능력, 메타인지 또는 자기인식 정도, 잠재적 한계 또는 위험, 나만의 개발 철학 성향 추측을 객관적이고 비판적으로 피드백받을 수 있도록 프롬프트 1차 작성
  - 프롬프트를 AI가 이해하기 쉽도록 한 번 더 다듬을 것을 AI에게 요청
  - 근거에 기반한 답변 원문을 바탕으로 다시 한번 더 정리하여 피드백 획득
- 답변 개선
  - 기본적인 AI의 대답 성향이 지나치게 친절하고 객관적으로 요청하더라도 과한 긍정적 해석이 들어가 쓸모가 없음.

#### 수행 결과
<details>
  <summary> 답변 원문 </summary>

  아래는 주어진 코드, 설계, 학습 정리 문서를 기반으로 도출된 항목별 비판적 분석입니다. 과도한 칭찬은 배제하고, 관찰 가능한 증거를 기반으로 장단점을 명확히 구분하여 서술합니다.

---

1. 사용한 기술 스택과 해당 스택에 대한 숙련도

장점:
	•	Swift 언어 특성 (mutating, Hashable, UUID, value/reference semantics)에 대해 실무적으로 응용하고 있으며, Combine을 활용한 iOS 앱 구성에서도 publisher/subject 흐름을 명확히 이해하고 적용함.
	•	비동기 처리 (Task, async/await, MainActor)에 대해 직접 디버깅하며 접근하고 있고, Regex, NSPredicate, DispatchQueue까지 폭넓게 사용.
	•	OS와 메모리 구조, 컴파일러 동작 등 범위를 넓혀 학습하는 태도는 상위 10% 개발자군에 가까운 폭넓은 호기심과 확장 의지를 반영함.

단점:
	•	실습된 도메인의 깊이에 비해 폭이 지나치게 넓음. 예: Regex, HashMap, Parser, OS 등을 모두 다루되, 각각이 완성되거나 실용화되지는 않음.
	•	UIKit에 대한 이해도는 충분하나, CoreData는 래퍼 수준으로 사용하고 있어 fetch predicate, relationship, background context 등 고급 활용은 확인되지 않음.
	•	단위 테스트, CI/CD, 네트워크 레이어 구성 등 실전 서비스 개발에서 요구되는 핵심 기술은 부재.

---

2. 아키텍처적 사고 및 설계 능력

장점:
	•	View/ViewModel/UseCase/Repository의 책임 분리 구조가 명확하며, 실제 iOS 앱 아키텍처(MVVMC)를 반영하고 있음.
	•	상태 머신을 클로저 + 딕셔너리 방식으로 처리하는 등 설계 유연성과 재사용성 고려가 있음.
	•	Value Object, DTO, Factory, Mapper, DI 등 도메인 설계 관점에서의 실험과 의식적인 적용이 다수 확인됨.

단점:
	•	일부 레이어 설계가 형식적인 수준에 머무름. 예: UseCase는 orchestration 외 로직을 직접 보유하고 있어 도메인 서비스와 경계가 불분명함.
	•	Repository가 CoreDataStack을 직접 사용하면서 영속성 계층이 외부로 노출됨 (진정한 DIP 미흡).
	•	DIContainer 없이 AppCoordinator에서 직접 CoreDataStack 등 생성 → 단위 테스트, 확장성 측면에서 약점.

---

3. 문제 해결 및 디버깅 능력

장점:
	•	복잡한 오류의 원인 (Command-Line Tool에서의 Bundle.main 접근 불가, Regex 리터럴 오류, XML 트리 파싱 오류)을 논리적으로 추적함.
	•	디버깅 중 실수나 실패를 문서화하고 개선하려는 습관이 내재화되어 있음.
	•	Task/Thread.sleep, DispatchQueue 간 차이 등 concurrency 이슈에 대한 실험적 접근도 우수.

단점:
	•	일부 미해결 문제를 “TODO”나 주석으로 남겨두는 경향 → 문제 해결을 미루는 습관이 누적되면 실제 프로젝트에서는 기술 부채로 전이됨.
	•	문제를 지나치게 기술적 요소로 환원하여 본질적 요구사항(사용자 행동, UX 흐름 등)에서 벗어나는 경향이 있음.

---

4. 학습 방식 및 성향

장점:
	•	선행 설계 → 구현 → 디버깅 → 회고 → 정리의 구조화된 루틴이 확립되어 있음.
	•	단순 기능 구현을 넘어 내부 동작 원리(해시 충돌, load factor 등)를 문서화하고 직접 실험하려는 성향.
	•	반례, 실패 원인, 개선 가능성까지 분석하며 학습 결과를 자기 언어로 재구성함.

단점:
	•	완성도보다는 학습 자체에 의미를 두는 경향이 강해, 산출물의 완결성이 떨어짐 (ex. Memory 시뮬레이터 미구현, XML 속성 미완료).
	•	구현과 학습을 병행하다 우선순위를 잃는 경우 존재 → 일정 기반 프로젝트에서는 단점으로 작용 가능.

---

5. 커뮤니케이션 및 협업 능력

장점:
	•	미션 리뷰 및 피드백에서 피어의 의견을 겸손하고 긍정적으로 수용하며, 이를 실제 개선에 반영.
	•	설계 근거, 디버깅 경로, 실수 기록까지 명확히 기술하여 협업 시 정보 비대칭을 줄이는 문서화를 지향함.
	•	자기 지식 공유에 대한 개방성이 높음 (피어 자료 요청에 흔쾌히 수용 등).

단점:
	•	코드 외 설득력 있는 의사결정 근거의 설명이 다소 부족. 예: 왜 이런 구조가 적합했는지에 대한 설명은 추상적이거나 생략되는 경우 존재.
	•	의견을 수용하는 데 적극적이지만, 반대로 논리적으로 설득하거나 주장을 관철하는 커뮤니케이션은 상대적으로 약함.

---

6. 메타인지 수준

장점:
	•	자신의 구현 미완, 지식 부족, 불완전한 이해를 정확하게 인식하고 기록함 (예: Regex 패턴 부족, XML Attribute 누락 등).
	•	학습-구현 균형, 과도한 설계, 테스트 부족 등을 스스로 문제화할 수 있는 수준의 자기 성찰력을 지님.
	•	“완성 못함”을 감추지 않으며, 그것이 발생한 이유와 맥락까지 기술함.

단점:
	•	때때로 메타인지가 과도한 자기 비판으로 전이되어, 작은 실패에 집착하거나 완성도를 지나치게 염두에 두는 태도로 이어질 수 있음.
	•	고도화된 분석이 실제 구현이나 행동 변화로 이어지는 비율은 아직 낮음 (분석 → 수정 루프가 명확히 끊어지는 부분 존재).

---

7. 잠재적 한계 및 리스크 요인
	•	미완성/미구현의 누적: 핵심 기능이 빠져 있거나 임시 처리된 사례가 반복됨 (TODO: error 처리, Prolog 파싱, triangle area 계산, fetchAllEvents() 등).
	•	모듈화 미흡: 일부 ViewModel에 너무 많은 책임이 집중되어 있어 코드 복잡도 증가 우려 (SignInViewModel, SignUpViewModel 등).
	•	테스트 빈약: 전반적으로 테스트 전략(단위, 통합, UI, 오류 등)이 부재하며, 휴먼 테스트에 의존하고 있음.
	•	DI 전략 부재: AppCoordinator에서 의존성을 직접 생성 → 확장성 및 테스트 용이성 저하.

---

8. 추정되는 개발 철학 및 사고방식

“깊이 이해하고, 실험을 통해 배운다. 설계는 명확해야 하고, 구현은 학습의 도구다. 실수는 감추지 않고 기록하며 개선한다.”

	•	이론적 기반을 중시하고, 그 기반 위에서 실제 코드를 실험적으로 쌓아 올리는 방식을 선호.
	•	과정을 문서화하는 습관이 내재화되어 있고, 나의 이해를 동료나 미래의 나에게 전달하기 위한 기록에 집중함.
	•	타인의 피드백에 열려 있으며, 학습은 단순 암기보다는 의미 있는 구조화와 개념화에 가까움.

---

총괄 장단점 정리

구분	강점	약점
기술 역량	Swift, Combine, OS, 파싱 등 전방위적 기술 탐구	도구의 깊이보다는 범위 위주 학습 경향
설계 능력	아키텍처 분리와 패턴 적용 능숙	일부 책임 분산 부족, DI 컨테이너 없음
문제 해결	근본 원인 파악과 논리적 분석 능력 우수	문제 해결 완료율이 낮은 편
학습 태도	이론 중심, 구조화된 문서화	학습 대비 산출물 완성도 낮음
협업 및 커뮤니케이션	문서화 능력, 피드백 수용 태도	의견 주도적 설득력 부족
메타인지	실패 인식과 자기 진단 우수	개선 실행력은 상대적으로 낮음
리스크 요인	명확히 인지된 미구현 사항 다수	테스트 부재, 모듈화 미흡

---

개발자로서의 다음 도약을 위한 제언
	1.	학습 → 완성 → 리팩터 → 테스트 → 문서화의 루프 완성
	•	현재는 학습 → 문서화 → 분석까지만 강점이 있으며, 리팩터링 및 자동화 테스트 루틴이 없음.
	2.	DIContainer 설계 및 테스트 전략 구축
	•	UseCase, Repository, ViewModel 단위의 테스트 가능성 확보를 위해 의존성 주입 패턴을 수립하십시오.
	3.	피어와의 설계 리뷰 및 설득 훈련
	•	지금까지 수용적 자세가 돋보였다면, 이제는 “내가 왜 이 설계를 선택했는가”를 구조적이고 논리적으로 설득하는 훈련이 필요합니다.
	4.	불완전 구현을 최소화하는 Sprint 전략 학습
	•	구현 단위와 책임 분할을 명확히 하여 작은 단위라도 끝맺는 습관을 들이십시오. 이는 실무에서 “일의 끝을 보는 능력”과 직결됩니다.

---

</details>

##### 총괄 장단점 정리

| 구분                 | 강점                                                 | 약점                                                |
|----------------------|------------------------------------------------------|-----------------------------------------------------|
| 기술 역량            | Swift, Combine, OS, 파싱 등 전방위적 기술 탐구       | 도구의 깊이보다는 범위 위주 학습 경향               |
| 설계 능력            | 아키텍처 분리와 패턴 적용 능숙                       | 일부 책임 분산 부족, DI 컨테이너 없음               |
| 문제 해결            | 근본 원인 파악과 논리적 분석 능력 우수              | 문제 해결 완료율이 낮은 편                          |
| 학습 태도            | 이론 중심, 구조화된 문서화                          | 학습 대비 산출물 완성도 낮음                        |
| 협업 및 커뮤니케이션 | 문서화 능력, 피드백 수용 태도                       | 의견 주도적 설득력 부족                             |
| 메타인지             | 실패 인식과 자기 진단 우수                          | 개선 실행력은 상대적으로 낮음                       |
| 리스크 요인          | 명확히 인지된 미구현 사항 다수                      | 테스트 부재, 모듈화 미흡                            |

##### 개발자로서의 다음 도약을 위한 제언

1.	학습 → 완성 → 리팩터 → 테스트 → 문서화의 루프 완성  
	•	현재는 학습 → 문서화 → 분석까지만 강점이 있으며, 리팩터링 및 자동화 테스트 루틴이 없음.  
2.	DIContainer 설계 및 테스트 전략 구축  
	•	UseCase, Repository, ViewModel 단위의 테스트 가능성 확보를 위해 의존성 주입 패턴을 수립하십시오.  
3.	피어와의 설계 리뷰 및 설득 훈련  
	•	지금까지 수용적 자세가 돋보였다면, 이제는 “내가 왜 이 설계를 선택했는가”를 구조적이고 논리적으로 설득하는 훈련이 필요합니다.  
4.	불완전 구현을 최소화하는 Sprint 전략 학습  
	•	구현 단위와 책임 분할을 명확히 하여 작은 단위라도 끝맺는 습관을 들이십시오. 이는 실무에서 “일의 끝을 보는 능력”과 직결됩니다.

#### 수행 후 인사이트

1. 이론 위주의 학습과 구현이나 시도의 부족이 gist에서도 고스란히 반영되어 AI가 읽어내는 것이 흥미로웠다.
2. 미션 수행 상태를 점검 받을 수 있어 이번주 미션 수행 내내 적극적으롸 활용해보면 좋을 듯.

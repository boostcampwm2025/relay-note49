| 이름               |박진홍|
| ------------------ | --- |
| 선택한 퀘스트 번호 |1, 2, 3, 4|
| 선택한 이유        |설계 의도가 순차적으로 하나씩 수행하여 최종 결과를 만들어내는 것이라 의도에 맞게 수행해보기 위함|
| 수행 과정          |      |
| 발견한 개선점      |     |
| 수행 후 인사이트   |     |

### Day 01
#### 발견한 개선점
- 퀘스트의 예시에는 내가 어떤 성향, 장·단점, 어떤 개발자인지 그간의 대화를 바탕으로 얻도록 유도함
- 그러나 계정을 공유하거나 대화를 전부 추적할 수 없는 1회용 세션 AI를 위주로 쓰는 사람이라면 대화를 바탕으로 한 피드백 획득이 어려울 수 있음
- 따라서 챌린지 과정이나 **기존에 작성한 코드, 학습 정리, 설계를 전달하여 분석받아 개발자로서의 성향을 피드백 받는다**면 좋을 것이라 생각함
- 특히 학습 시키는 내용이 많을수록 더욱 자세하고 정밀한 피드백을 받을 가능성이 높아질 것으로 예상됨
- 이는 **몰랐던 자신만의 개발 철학을 발견할 수 있는 계기**가 될 수도 있을 듯함

#### 수행 과정
- 사용한 AI: NoteBookLM
  - AI 선택 이유: 원하는 소스를 안전하게 학습 시켜 근거에 기반한 피드백을 받기 가장 적절하기 때문
- 소스 제공
  - 기존 프로젝트 1개 분량 코드와 설계, 트러블 슈팅 등을 전달
  - 챌린지 미션 1–4, 베이직 미션 1–10에 해당하는 gist 링크 전달
- 질문 프롬프트
  - 기술 스택, 숙련도, 설계 및 아키텍처 사고, 문제 해결 방식, 학습 방식, 학습 성향, 커뮤니케이션 또는 협업에서의 능력, 메타인지 또는 자기인식 정도, 잠재적 한계 또는 위험, 나만의 개발 철학 성향 추측을 객관적이고 비판적으로 피드백받을 수 있도록 프롬프트 1차 작성
  - 프롬프트를 AI가 이해하기 쉽도록 한 번 더 다듬을 것을 AI에게 요청
  - 근거에 기반한 답변 원문을 바탕으로 다시 한번 더 정리하여 피드백 획득
- 답변 개선
  - 기본적인 AI의 대답 성향이 지나치게 친절하고 객관적으로 요청하더라도 과한 긍정적 해석이 들어가 쓸모가 없음.

#### 수행 결과
<details>
  <summary> 답변 원문 </summary>

  아래는 주어진 코드, 설계, 학습 정리 문서를 기반으로 도출된 항목별 비판적 분석입니다. 과도한 칭찬은 배제하고, 관찰 가능한 증거를 기반으로 장단점을 명확히 구분하여 서술합니다.

---

1. 사용한 기술 스택과 해당 스택에 대한 숙련도

장점:
	•	Swift 언어 특성 (mutating, Hashable, UUID, value/reference semantics)에 대해 실무적으로 응용하고 있으며, Combine을 활용한 iOS 앱 구성에서도 publisher/subject 흐름을 명확히 이해하고 적용함.
	•	비동기 처리 (Task, async/await, MainActor)에 대해 직접 디버깅하며 접근하고 있고, Regex, NSPredicate, DispatchQueue까지 폭넓게 사용.
	•	OS와 메모리 구조, 컴파일러 동작 등 범위를 넓혀 학습하는 태도는 상위 10% 개발자군에 가까운 폭넓은 호기심과 확장 의지를 반영함.

단점:
	•	실습된 도메인의 깊이에 비해 폭이 지나치게 넓음. 예: Regex, HashMap, Parser, OS 등을 모두 다루되, 각각이 완성되거나 실용화되지는 않음.
	•	UIKit에 대한 이해도는 충분하나, CoreData는 래퍼 수준으로 사용하고 있어 fetch predicate, relationship, background context 등 고급 활용은 확인되지 않음.
	•	단위 테스트, CI/CD, 네트워크 레이어 구성 등 실전 서비스 개발에서 요구되는 핵심 기술은 부재.

---

2. 아키텍처적 사고 및 설계 능력

장점:
	•	View/ViewModel/UseCase/Repository의 책임 분리 구조가 명확하며, 실제 iOS 앱 아키텍처(MVVMC)를 반영하고 있음.
	•	상태 머신을 클로저 + 딕셔너리 방식으로 처리하는 등 설계 유연성과 재사용성 고려가 있음.
	•	Value Object, DTO, Factory, Mapper, DI 등 도메인 설계 관점에서의 실험과 의식적인 적용이 다수 확인됨.

단점:
	•	일부 레이어 설계가 형식적인 수준에 머무름. 예: UseCase는 orchestration 외 로직을 직접 보유하고 있어 도메인 서비스와 경계가 불분명함.
	•	Repository가 CoreDataStack을 직접 사용하면서 영속성 계층이 외부로 노출됨 (진정한 DIP 미흡).
	•	DIContainer 없이 AppCoordinator에서 직접 CoreDataStack 등 생성 → 단위 테스트, 확장성 측면에서 약점.

---

3. 문제 해결 및 디버깅 능력

장점:
	•	복잡한 오류의 원인 (Command-Line Tool에서의 Bundle.main 접근 불가, Regex 리터럴 오류, XML 트리 파싱 오류)을 논리적으로 추적함.
	•	디버깅 중 실수나 실패를 문서화하고 개선하려는 습관이 내재화되어 있음.
	•	Task/Thread.sleep, DispatchQueue 간 차이 등 concurrency 이슈에 대한 실험적 접근도 우수.

단점:
	•	일부 미해결 문제를 “TODO”나 주석으로 남겨두는 경향 → 문제 해결을 미루는 습관이 누적되면 실제 프로젝트에서는 기술 부채로 전이됨.
	•	문제를 지나치게 기술적 요소로 환원하여 본질적 요구사항(사용자 행동, UX 흐름 등)에서 벗어나는 경향이 있음.

---

4. 학습 방식 및 성향

장점:
	•	선행 설계 → 구현 → 디버깅 → 회고 → 정리의 구조화된 루틴이 확립되어 있음.
	•	단순 기능 구현을 넘어 내부 동작 원리(해시 충돌, load factor 등)를 문서화하고 직접 실험하려는 성향.
	•	반례, 실패 원인, 개선 가능성까지 분석하며 학습 결과를 자기 언어로 재구성함.

단점:
	•	완성도보다는 학습 자체에 의미를 두는 경향이 강해, 산출물의 완결성이 떨어짐 (ex. Memory 시뮬레이터 미구현, XML 속성 미완료).
	•	구현과 학습을 병행하다 우선순위를 잃는 경우 존재 → 일정 기반 프로젝트에서는 단점으로 작용 가능.

---

5. 커뮤니케이션 및 협업 능력

장점:
	•	미션 리뷰 및 피드백에서 피어의 의견을 겸손하고 긍정적으로 수용하며, 이를 실제 개선에 반영.
	•	설계 근거, 디버깅 경로, 실수 기록까지 명확히 기술하여 협업 시 정보 비대칭을 줄이는 문서화를 지향함.
	•	자기 지식 공유에 대한 개방성이 높음 (피어 자료 요청에 흔쾌히 수용 등).

단점:
	•	코드 외 설득력 있는 의사결정 근거의 설명이 다소 부족. 예: 왜 이런 구조가 적합했는지에 대한 설명은 추상적이거나 생략되는 경우 존재.
	•	의견을 수용하는 데 적극적이지만, 반대로 논리적으로 설득하거나 주장을 관철하는 커뮤니케이션은 상대적으로 약함.

---

6. 메타인지 수준

장점:
	•	자신의 구현 미완, 지식 부족, 불완전한 이해를 정확하게 인식하고 기록함 (예: Regex 패턴 부족, XML Attribute 누락 등).
	•	학습-구현 균형, 과도한 설계, 테스트 부족 등을 스스로 문제화할 수 있는 수준의 자기 성찰력을 지님.
	•	“완성 못함”을 감추지 않으며, 그것이 발생한 이유와 맥락까지 기술함.

단점:
	•	때때로 메타인지가 과도한 자기 비판으로 전이되어, 작은 실패에 집착하거나 완성도를 지나치게 염두에 두는 태도로 이어질 수 있음.
	•	고도화된 분석이 실제 구현이나 행동 변화로 이어지는 비율은 아직 낮음 (분석 → 수정 루프가 명확히 끊어지는 부분 존재).

---

7. 잠재적 한계 및 리스크 요인
	•	미완성/미구현의 누적: 핵심 기능이 빠져 있거나 임시 처리된 사례가 반복됨 (TODO: error 처리, Prolog 파싱, triangle area 계산, fetchAllEvents() 등).
	•	모듈화 미흡: 일부 ViewModel에 너무 많은 책임이 집중되어 있어 코드 복잡도 증가 우려 (SignInViewModel, SignUpViewModel 등).
	•	테스트 빈약: 전반적으로 테스트 전략(단위, 통합, UI, 오류 등)이 부재하며, 휴먼 테스트에 의존하고 있음.
	•	DI 전략 부재: AppCoordinator에서 의존성을 직접 생성 → 확장성 및 테스트 용이성 저하.

---

8. 추정되는 개발 철학 및 사고방식

“깊이 이해하고, 실험을 통해 배운다. 설계는 명확해야 하고, 구현은 학습의 도구다. 실수는 감추지 않고 기록하며 개선한다.”

	•	이론적 기반을 중시하고, 그 기반 위에서 실제 코드를 실험적으로 쌓아 올리는 방식을 선호.
	•	과정을 문서화하는 습관이 내재화되어 있고, 나의 이해를 동료나 미래의 나에게 전달하기 위한 기록에 집중함.
	•	타인의 피드백에 열려 있으며, 학습은 단순 암기보다는 의미 있는 구조화와 개념화에 가까움.

---

총괄 장단점 정리

구분	강점	약점
기술 역량	Swift, Combine, OS, 파싱 등 전방위적 기술 탐구	도구의 깊이보다는 범위 위주 학습 경향
설계 능력	아키텍처 분리와 패턴 적용 능숙	일부 책임 분산 부족, DI 컨테이너 없음
문제 해결	근본 원인 파악과 논리적 분석 능력 우수	문제 해결 완료율이 낮은 편
학습 태도	이론 중심, 구조화된 문서화	학습 대비 산출물 완성도 낮음
협업 및 커뮤니케이션	문서화 능력, 피드백 수용 태도	의견 주도적 설득력 부족
메타인지	실패 인식과 자기 진단 우수	개선 실행력은 상대적으로 낮음
리스크 요인	명확히 인지된 미구현 사항 다수	테스트 부재, 모듈화 미흡

---

개발자로서의 다음 도약을 위한 제언
	1.	학습 → 완성 → 리팩터 → 테스트 → 문서화의 루프 완성
	•	현재는 학습 → 문서화 → 분석까지만 강점이 있으며, 리팩터링 및 자동화 테스트 루틴이 없음.
	2.	DIContainer 설계 및 테스트 전략 구축
	•	UseCase, Repository, ViewModel 단위의 테스트 가능성 확보를 위해 의존성 주입 패턴을 수립하십시오.
	3.	피어와의 설계 리뷰 및 설득 훈련
	•	지금까지 수용적 자세가 돋보였다면, 이제는 “내가 왜 이 설계를 선택했는가”를 구조적이고 논리적으로 설득하는 훈련이 필요합니다.
	4.	불완전 구현을 최소화하는 Sprint 전략 학습
	•	구현 단위와 책임 분할을 명확히 하여 작은 단위라도 끝맺는 습관을 들이십시오. 이는 실무에서 “일의 끝을 보는 능력”과 직결됩니다.

---

</details>

##### 총괄 장단점 정리

| 구분                 | 강점                                                 | 약점                                                |
|----------------------|------------------------------------------------------|-----------------------------------------------------|
| 기술 역량            | Swift, Combine, OS, 파싱 등 전방위적 기술 탐구       | 도구의 깊이보다는 범위 위주 학습 경향               |
| 설계 능력            | 아키텍처 분리와 패턴 적용 능숙                       | 일부 책임 분산 부족, DI 컨테이너 없음               |
| 문제 해결            | 근본 원인 파악과 논리적 분석 능력 우수              | 문제 해결 완료율이 낮은 편                          |
| 학습 태도            | 이론 중심, 구조화된 문서화                          | 학습 대비 산출물 완성도 낮음                        |
| 협업 및 커뮤니케이션 | 문서화 능력, 피드백 수용 태도                       | 의견 주도적 설득력 부족                             |
| 메타인지             | 실패 인식과 자기 진단 우수                          | 개선 실행력은 상대적으로 낮음                       |
| 리스크 요인          | 명확히 인지된 미구현 사항 다수                      | 테스트 부재, 모듈화 미흡                            |

##### 개발자로서의 다음 도약을 위한 제언

1.	학습 → 완성 → 리팩터 → 테스트 → 문서화의 루프 완성  
	•	현재는 학습 → 문서화 → 분석까지만 강점이 있으며, 리팩터링 및 자동화 테스트 루틴이 없음.  
2.	DIContainer 설계 및 테스트 전략 구축  
	•	UseCase, Repository, ViewModel 단위의 테스트 가능성 확보를 위해 의존성 주입 패턴을 수립하십시오.  
3.	피어와의 설계 리뷰 및 설득 훈련  
	•	지금까지 수용적 자세가 돋보였다면, 이제는 “내가 왜 이 설계를 선택했는가”를 구조적이고 논리적으로 설득하는 훈련이 필요합니다.  
4.	불완전 구현을 최소화하는 Sprint 전략 학습  
	•	구현 단위와 책임 분할을 명확히 하여 작은 단위라도 끝맺는 습관을 들이십시오. 이는 실무에서 “일의 끝을 보는 능력”과 직결됩니다.

#### 수행 후 인사이트

1. 이론 위주의 학습과 구현이나 시도의 부족이 gist에서도 고스란히 반영되어 AI가 읽어내는 것이 흥미로웠다.
2. 미션 수행 상태를 점검 받을 수 있어 이번주 미션 수행 내내 적극적으롸 활용해보면 좋을 듯.

### Day02
#### 수행 과정
특정 화풍 요청과 함께 데스크테리어 사진을 올려 개발하는 모습을 그려달라고 요청.
#### 수행 결과
![](https://velog.velcdn.com/images/landelyse/post/ce311fc0-6f14-4aef-aa42-d3c3310a623b/image.png)


### Day03
가볍게 수행하기엔 지나온 일들을 모두 나열하는 데 소모되는 시간이 너무 크다고 판단됨  
AI에게 설명하는 프롬트에 이미 결과물의 핵심 요소인 시간 + 경험 + 가치가 담겨있어야 함  
때문에 대화 기반으로 내가 추구하는 가치를 판단해달라고 요청함

| 가치               | 설명                                                                 | 실제로 드러난 행동 예시                                                      |
|------------------|----------------------------------------------------------------------|----------------------------------------------------------------------------|
| 정합성 (Consistency) | 개념, 설계, 구현 간 논리적·구조적 일관성을 중시하며, 비직관적인 구성에 불편함을 느낌 | MVC → MVVM → MVVMC 구조로 발전. “의존성 생명주기”에 대한 집요한 통제 시도         |
| 메타인지 (Metacognition) | 자신이 이해한 수준을 객관화하고, 모르는 것을 인정하고 보완하려는 태도                 | 테스트 더블, 파일 시스템, ARC 등에서 “내가 정확히 이해했는가”를 반복적으로 검증    |
| 비판적 사고 (Critical Thinking) | 주어진 정보를 그대로 수용하지 않고 원리·정의·동작 원리를 직접 분석해 받아들임        | Swinject, Coordinator 등에서 내부 작동 방식을 파고들며 “왜 그렇게 되어야 하는가” 질문 |
| 자율성/통제력 (Autonomy) | 외부 도구나 설계에 휘둘리기보다 자신이 설계한 흐름과 구조를 선호함                 | Combine, DI 등 도입 시에도 "내 흐름에 맞는지" 판단 후 수용, 흡수하지 않음         |
| 구조화된 사고 (Structured Thinking) | 개념이나 코드를 구조 단위로 분해·재조립하며 체계적으로 정리하려는 경향             | 파일 시스템 구현 시 디스크 구조, 디렉토리, CLI 등 개념을 분리하여 단계적으로 구성   |
| 실증적 학습 (Empirical Learning) | 이해가 아닌 구현, 구현이 아닌 검증까지를 학습으로 봄                            | "디코딩 에러를 일으켜 보며 설계", "직접 구조체의 테스트를 구성" 등의 언급          |
| 절제된 커뮤니케이션 (Disciplined Communication) | 감정적 배려보다는 명확하고 직설적인 피드백을 중시함                              | “공감은 필요 없고, 내가 들어야 할 말만 해라”, “정확하고 비판적으로 말하라” 등의 메타 지시  |
| 성장 재사용성 (Reusable Growth) | 단기 성과보다 학습 과정 자체의 반복 가능성, 구조화 가능성을 중시함               | 회고, 학습 정리, 구조별 비교 등을 통해 학습의 재사용 구조를 구축하려는 시도         |

### Day04
<details>
	<summary> 결과 </summary>
### 개발자 포트폴리오

## 박진홍

---

## 1. 기술 스택 및 숙련도

**사용 기술 스택**

* Swift, Combine, UIKit, CoreData, Regex, NSPredicate, DispatchQueue, Task(async/await), OS 구조

**숙련도**

* Swift 언어 특징(value/reference semantics, Hashable, mutating, UUID 등)을 명확히 이해하고 응용 가능
* Combine을 활용하여 iOS 앱의 데이터 흐름을 능숙하게 관리 가능
* 비동기 처리 및 concurrency 개념에 대한 깊은 이해를 바탕으로 한 문제 해결 및 디버깅
* OS와 메모리 구조 등 시스템 전반에 대한 학습과 이해가 폭넓음

**한계점**

* 깊이보다는 넓은 범위에 대한 탐구로 인해 각 분야의 전문성 부족
* CoreData의 고급 기능(백그라운드 컨텍스트 등) 활용 부족
* 단위 테스트 및 CI/CD, 네트워크 계층에 대한 실전적 경험 부족

---

## 2. 아키텍처 설계 및 사고력

**장점**

* MVVMC 구조의 책임 분리를 명확히 구현하고 있음
* 상태 머신을 활용한 유연한 설계 능력 보유
* Value Object, DTO, Mapper, DI 등 설계 관점에서 명확한 구조화를 지속적으로 실험

**개선 필요**

* 일부 레이어(UseCase 등)의 책임이 모호하며, Repository의 영속성 계층이 외부로 노출되는 문제 존재
* DIContainer의 부재로 인해 의존성 관리가 비효율적이며, 확장성과 테스트 용이성 저하 가능

---

## 3. 문제 해결 및 디버깅 역량

**강점**

* 복잡한 문제(Regex, XML 파싱 오류 등)의 근본 원인을 정확히 분석하고 해결
* 디버깅 과정을 문서화하며 개선점을 도출하는 습관 내재화
* concurrency 이슈에 대한 논리적이며 실험적인 접근 방식

**개선 필요**

* 문제를 미완으로 남기는 경향 존재(TODO 주석 등)
* 문제의 본질적 요구사항(사용자 경험, UX)보다는 기술적 요소에만 초점 맞추는 경향

---

## 4. 학습 방식 및 태도

**강점**

* 선행 설계 → 구현 → 디버깅 → 회고 → 정리의 체계적인 루틴 구축
* 이론을 문서화하고 직접 실험을 통해 깊게 이해하려는 성향
* 실패 사례 및 반례를 철저히 분석하고 자기 언어로 재구성하여 학습

**개선 필요**

* 학습 목적이 강해 실제 완성도와 완결성이 다소 낮음
* 구현과 학습의 우선순위 조정 미흡으로 프로젝트 일정 관리 측면의 리스크 존재

---

## 5. 커뮤니케이션 및 협업 능력

**장점**

* 피어 피드백 수용에 겸손하며, 개선 사항 적극 반영
* 명확한 문서화로 협업 효율 증대
* 지식 공유 및 개방적 커뮤니케이션 유지

**개선 필요**

* 의사결정의 논리적이고 설득력 있는 근거 설명 미흡
* 자신의 의견을 설득하고 관철시키는 능력이 상대적으로 약함

---

## 6. 메타인지 역량

**장점**

* 자신의 부족함(Regex, XML Attribute 미완 등)을 객관적으로 인지하고 기록함
* 과도한 설계, 학습과 구현 균형, 테스트 부족 등을 스스로 문제화하며 성찰 가능

**개선 필요**

* 과도한 자기 비판으로 인해 작은 실패에 집착하는 경향 존재
* 메타인지 분석을 행동 변화와 실제 구현으로 이어가는 데 있어 실행력이 부족

---

## 7. 잠재 리스크 요인

* 미완성 및 미구현 기능의 반복적 누적으로 인한 기술 부채 가능성
* 일부 ViewModel의 과도한 책임 집중으로 코드 복잡도 증가
* 테스트 전략 미비로 품질 관리 취약성
* DI 전략의 미흡으로 인해 유지보수와 확장성 제한

---

## 8. 개발 철학 및 가치관

> "깊이 이해하고, 실험을 통해 배우며, 명확한 설계를 바탕으로 구현하고, 실수를 기록하여 개선한다."

* **정합성**: MVVM → MVVMC로 발전, 의존성 생명주기에 대한 철저한 통제
* **메타인지**: 정확한 이해 여부를 반복 검증
* **비판적 사고**: 내부 작동 원리 분석을 통한 근본적 이해
* **자율성/통제력**: 도구와 설계를 무조건 흡수하지 않고 자신의 구조에 맞게 적용
* **구조화된 사고**: 복잡한 개념을 단계적으로 분리하여 명확히 구현
* **실증적 학습**: 직접 구현과 검증을 통한 학습
* **절제된 커뮤니케이션**: 감정적 공감보다 정확하고 직설적인 피드백 선호
* **성장 재사용성**: 반복 가능하며 구조화된 학습 프로세스 구축

---

## 총괄 평가

| 구분      | 강점                   | 개선 필요                      |
| ------- | -------------------- | -------------------------- |
| 기술 역량   | Swift 및 폭넓은 기술 탐구 능력 | 깊이 있는 전문성 강화 필요            |
| 아키텍처 설계 | 구조적 책임 분리 능숙         | 책임 경계 및 DI 전략 개선 필요        |
| 문제 해결   | 논리적이고 분석적인 접근력       | 문제 해결의 완료율 향상 필요           |
| 학습 태도   | 이론 중심의 문서화 및 학습 구조화  | 산출물의 완성도와 우선순위 관리 개선 필요    |
| 협업 및 소통 | 명확한 문서화 및 피드백 수용 능력  | 의사결정 설득력 및 주도성 강화 필요       |
| 메타인지    | 정확한 자기 진단과 성찰력       | 자기 비판을 실제 행동으로 전환하는 실행력 필요 |
| 리스크 관리  | 미구현 사항의 명확한 인지       | 테스트 전략 및 모듈화 개선 필요         |

</details>
